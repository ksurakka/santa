<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lunawood ‚Äì Santa's Sleigh</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0b1f4b 0%, #0b3a7a 35%, #062a5a 70%, #041026 100%);
      color: white;
      overflow: hidden;
    }
    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
    }
    canvas {
      background: transparent;
      display: block;
      border-radius: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      user-select: none;
    }
    #ui h1 {
      margin: 0 0 6px 0;
      font-size: 20px;
    }
    #ui p {
      margin: 0;
      font-size: 14px;
      opacity: 0.95;
    }
    #hint {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }

    /* Santa + speech bubble (overlay) */
    #santa {
      position: absolute;
      right: 0;
      bottom: 120px;
      display: flex;
      align-items: flex-end;
      gap: 12px;
      transform: translateX(320px); /* hidden off-screen */
      transition: transform 600ms ease;
      pointer-events: none;
      z-index: 20;
    }
    #santa.show {
      /* peek just a little */
      transform: translateX(-10px);
    }
    #santa .santaFigure {
      position: relative;
      width: 150px;
      height: 150px;
      transform: rotate(-10deg);
      transform-origin: 100% 100%;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.35));
    }
    #santa .santaBody {
      position: absolute;
      right: 6px;
      bottom: -52px;
      width: 128px;
      height: 128px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,0.18), rgba(0,0,0,0) 45%),
        radial-gradient(circle at 65% 70%, rgba(0,0,0,0.18), rgba(0,0,0,0) 55%),
        #c81e1e;
      border: 3px solid rgba(255,255,255,0.22);
    }

    /* Santa's left waving arm */
    #santa .santaArm {
      position: absolute;
      left: -18px;
      bottom: 24px;
      width: 70px;
      height: 26px;
      background: #c81e1e;
      border-radius: 999px;
      transform-origin: 90% 50%;
      transform: rotate(-20deg);
      box-shadow: inset 0 0 0 3px rgba(255,255,255,0.22);
      animation: santaWave 1.6s ease-in-out infinite;
    }
    #santa .santaArm::after {
      content: "ü§ö";
      position: absolute;
      left: -18px;
      top: -14px;
      font-size: 28px;
      transform: rotate(10deg);
    }

    @keyframes santaWave {
      0% { transform: rotate(-25deg); }
      50% { transform: rotate(-5deg); }
      100% { transform: rotate(-25deg); }
    }

    #santa .santaEmoji {
      position: absolute;
      right: 52px;
      top: -18px;
      font-size: 128px;
      transform: translateY(8px);
      filter: drop-shadow(0 8px 14px rgba(0,0,0,0.28));
    }

    #santaBubble {
      max-width: 260px;
      padding: 12px 14px;
      background: rgba(255,255,255,0.92);
      color: #0b1f4b;
      border-radius: 16px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      font-size: 16px;
      line-height: 1.25;
      opacity: 0;
      transform: translateY(6px) scale(0.98);
      transition: opacity 220ms ease, transform 220ms ease;
      position: relative;
    }
    #santaBubble.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    #santaBubble::after {
      content: "";
      position: absolute;
      right: -10px;
      bottom: 18px;
      width: 0;
      height: 0;
      border-left: 12px solid rgba(255,255,255,0.92);
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.15));
    }
    #santaBubble.bad {
      background: rgba(255, 226, 226, 0.95);
      color: #7f1d1d;
    }
    #santaBubble.bad::after {
      border-left-color: rgba(255, 226, 226, 0.95);
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="ui">
      <h1>Lunawood ‚Äì Santa's Sleigh</h1>
      <p id="status">Load the packages onto the sleigh</p>
      <div id="hint">Controls: ‚¨ÖÔ∏è ‚û°Ô∏è move, ‚¨áÔ∏è speed up, ‚¨ÜÔ∏è rotate. (Press any key to start the music)</div>
    </div>

    <canvas id="canvas" width="1100" height="600"></canvas>

    <!-- Santa peeks in from the right and comments -->
    <div id="santa" aria-hidden="true">
      <div id="santaBubble"></div>
      <div class="santaFigure">
        <div class="santaBody" aria-hidden="true"></div>
        <div class="santaArm" aria-hidden="true"></div>
        <div class="santaEmoji">üéÖ</div>
      </div>
    </div>
  </div>

  <!-- Looping Christmas music (Web Audio ‚Äì Jingle Bells-ish melody) -->
  <script>
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    let musicStarted = false;
    let musicTimer = null;

    function ensureAudio() {
      if (!audioCtx) audioCtx = new AudioContext();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    const jingleBells = [
      { f: 659, d: 0.25 }, { f: 659, d: 0.25 }, { f: 659, d: 0.5 },
      { f: 659, d: 0.25 }, { f: 659, d: 0.25 }, { f: 659, d: 0.5 },
      { f: 659, d: 0.25 }, { f: 784, d: 0.25 }, { f: 523, d: 0.25 }, { f: 587, d: 0.25 }, { f: 659, d: 0.75 },
      { f: 698, d: 0.25 }, { f: 698, d: 0.25 }, { f: 698, d: 0.25 }, { f: 698, d: 0.25 }, { f: 698, d: 0.25 },
      { f: 659, d: 0.25 }, { f: 659, d: 0.25 }, { f: 659, d: 0.25 }, { f: 784, d: 0.25 }, { f: 784, d: 0.25 },
      { f: 698, d: 0.25 }, { f: 587, d: 0.25 }, { f: 523, d: 0.75 }
    ];

    function playSequence(sequence) {
      ensureAudio();
      let t = audioCtx.currentTime + 0.05;
      sequence.forEach(note => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = note.f;
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.exponentialRampToValueAtTime(0.05, t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + note.d);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t);
        osc.stop(t + note.d + 0.02);
        t += note.d;
      });
      return t - audioCtx.currentTime;
    }

    function playMusic() {
      if (musicStarted) return;
      musicStarted = true;
      const loop = () => {
        const duration = playSequence(jingleBells);
        musicTimer = setTimeout(loop, duration * 1000);
      };
      loop();
    }
  </script>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");

    // --- Package-side PNG logo (Safari-safe; avoids SVG-in-canvas issues) ---
    const lunawoodLogoPngBase64 = "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";

    const logoImg = new Image();
    let logoLoaded = false;
    logoImg.onload = () => { logoLoaded = true; };
    logoImg.src = "data:image/png;base64, " + lunawoodLogoPngBase64;

    const gridCols = 10;
    const gridRows = 6;
    const cell = 40;

    // Sled placement
    const sledX = 110;
    const sledY = 300;

    let grid = Array.from({ length: gridRows }, () => Array(gridCols).fill(0));
    let packagesLoaded = 0;
    const targetPackages = 14; // win condition
    const halfwayPackages = Math.floor(targetPackages / 2);
    let currentPackage = null;
    let reindeerShake = 0;
    let finished = false;
    let gameOver = false;

    // Flight offsets after win
    window.sledFlyOffsetX = 0;
    window.sledFlyOffsetY = 0;

    // Santa comments
    const santaGoodComments = [
      "Hou hou, let's go!",
      "Only A quality!",
      "Very good, very good!",
      "Yes yees!"
    ];
    const santaBadComment = "Nou nou, c'mon guys!";

    const santaEl = document.getElementById("santa");
    const santaBubble = document.getElementById("santaBubble");
    let santaIntroDone = false;
    let santaHideTimer = null;
    let santaSlideOutTimer = null;

    function showSanta(text, bad = false) {
      if (!santaEl || !santaBubble) return;

      clearTimeout(santaHideTimer);
      clearTimeout(santaSlideOutTimer);

      santaEl.classList.add("show");
      santaBubble.textContent = text;
      santaBubble.classList.toggle("bad", !!bad);
      santaBubble.classList.add("visible");

      santaHideTimer = setTimeout(() => {
        santaBubble.classList.remove("visible");
      }, 2200);

      santaSlideOutTimer = setTimeout(() => {
        santaEl.classList.remove("show");
      }, 4200);
    }

    function randomGoodComment() {
      return santaGoodComments[Math.floor(Math.random() * santaGoodComments.length)];
    }

    // "Bad" indicator: empty cells below filled ones (holes)
    function countHoles() {
      let holes = 0;
      for (let c = 0; c < gridCols; c++) {
        let seenFilled = false;
        for (let r = 0; r < gridRows; r++) {
          if (grid[r][c]) {
            seenFilled = true;
          } else if (seenFilled) {
            holes++;
          }
        }
      }
      return holes;
    }

    let prevHoles = 0;

    // Sparkle dust particles
    const dust = [];

    // Snow and stars
    const snowflakes = [];
    const stars = [];

    const packageShapes = [
      [[1, 1, 1, 1]],
      [[1, 1], [1, 1]],
      [[1, 1, 1], [0, 1, 0]],
      [[1, 1, 0], [0, 1, 1]],
    ];

    function newPackage() {
      const shape = packageShapes[Math.floor(Math.random() * packageShapes.length)];
      return { shape, x: 4, y: -5 };
    }

    currentPackage = newPackage();

    initStarsAndSnow();

    function drawPackageCell(x, y) {
      ctx.fillStyle = "#c68642";
      ctx.fillRect(x, y, cell, cell);
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.strokeRect(x + 0.5, y + 0.5, cell - 1, cell - 1);

      if (logoLoaded && logoImg.complete) {
        const pad = 4;
        const size = cell - pad * 2;
        ctx.globalAlpha = 0.92;
        ctx.drawImage(logoImg, x + pad, y + pad, size, size);
        ctx.globalAlpha = 1;
      } else {
        ctx.fillStyle = "#ffffff";
        ctx.font = "10px Arial";
        ctx.fillText("Lunawood", x + 4, y + 22);
      }
    }

    function drawGrid() {
      const flyX = window.sledFlyOffsetX || 0;
      const flyY = window.sledFlyOffsetY || 0;
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          if (grid[r][c]) {
            drawPackageCell(sledX + flyX + c * cell, sledY + flyY + r * cell);
          }
        }
      }
    }

    function drawCurrentPackage() {
      if (!currentPackage) return;
      const flyX = window.sledFlyOffsetX || 0;
      const flyY = window.sledFlyOffsetY || 0;
      currentPackage.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (!val) return;
          const px = sledX + flyX + (currentPackage.x + c) * cell;
          const py = sledY + flyY + (currentPackage.y + r) * cell;
          if (py > -cell && py < canvas.height + cell) {
            drawPackageCell(px, py);
          }
        });
      });
    }

    function drawSled() {
      const flyX = window.sledFlyOffsetX || 0;
      const flyY = window.sledFlyOffsetY || 0;
      const now = Date.now();
      const t = now / 220;

      ctx.save();
      ctx.translate(flyX, flyY + reindeerShake);

      const bodyTop = sledY - 30;
      const bodyBottom = sledY + gridRows * cell + 20;
      const bodyFront = sledX + gridCols * cell + 40;
      const bodyBack = sledX - 40;

      ctx.beginPath();
      ctx.moveTo(bodyBack, bodyTop + 20);
      ctx.lineTo(bodyFront, bodyTop);
      ctx.lineTo(bodyFront + 20, bodyBottom - 10);
      ctx.lineTo(bodyBack, bodyBottom + 5);
      ctx.quadraticCurveTo(bodyBack - 40, bodyBottom - 10, bodyBack - 10, bodyTop + 10);
      ctx.closePath();
      ctx.fillStyle = "#8b0000";
      ctx.fill();

      ctx.strokeStyle = "#facc15";
      ctx.lineWidth = 2.5;
      ctx.stroke();

      // Skids
      ctx.strokeStyle = "#b45309";
      ctx.lineCap = "round";

      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.moveTo(bodyBack - 40, bodyBottom + 14);
      ctx.quadraticCurveTo(bodyBack + 40, bodyBottom + 36, bodyFront + 90, bodyBottom + 18);
      ctx.quadraticCurveTo(bodyFront + 130, bodyBottom - 10, bodyFront + 70, bodyBottom - 6);
      ctx.stroke();

      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(bodyBack - 30, bodyBottom + 6);
      ctx.quadraticCurveTo(bodyBack + 50, bodyBottom + 22, bodyFront + 80, bodyBottom + 10);
      ctx.quadraticCurveTo(bodyFront + 110, bodyBottom - 16, bodyFront + 60, bodyBottom - 12);
      ctx.stroke();

      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.fillRect(sledX, sledY, gridCols * cell, gridRows * cell);

      ctx.restore();

      // Reindeer (6) ‚Äì big and spaced out
      const baseX = sledX + gridCols * cell + 200 + flyX;
      const baseY = sledY + 40 + flyY;
      const spacingX = 140;
      const spacingY = 130;

      ctx.font = "128px Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji";

      for (let i = 0; i < 6; i++) {
        const col = i % 3;
        const row = Math.floor(i / 3);

        const wobbleX = Math.sin(t * 0.6 + i * 1.4) * 2 + Math.sin(t * 2.5 + i) * 1;
        const wobbleY = Math.sin(t * 0.8 + i * 1.1) * 2 + Math.cos(t * 1.9 + i) * 1;

        const x = baseX + col * spacingX + wobbleX;
        const y = baseY + row * spacingY + wobbleY;

        // Harness line from sled to reindeer neck (reindeer end higher)
        const anchorX = sledX + gridCols * cell + 20 + flyX;
        const anchorYBase = sledY + gridRows * cell * 0.45 + flyY;
        const anchorY = anchorYBase + row * 26 - (row === 0 ? 10 : 0);

        ctx.strokeStyle = "rgba(148, 94, 38, 0.8)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(anchorX, anchorY);

        const neckX = x - 18;
        const neckY = y - 28;
        const midX = (anchorX + neckX) / 2;
        const midY = anchorY + 18 + row * 4;
        ctx.quadraticCurveTo(midX, midY, neckX, neckY);
        ctx.stroke();

        // Reindeer emoji (mirrored to face right)
        ctx.save();
        ctx.translate(x, 0);
        ctx.scale(-1, 1);
        ctx.fillText("ü¶å", 0, y);

        if (!finished && !gameOver && Math.sin(t * 1.6 + i) > 0.94) {
          const oldFont = ctx.font;
          ctx.font = "24px Segoe UI Emoji";
          ctx.fillText("‚ãØ", 26, y + 72);
          ctx.font = oldFont;
        }

        ctx.restore();
      }
    }

    function initStarsAndSnow() {
      stars.length = 0;
      for (let i = 0; i < 80; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height * 0.6,
          baseAlpha: 0.3 + Math.random() * 0.7,
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 1.5,
        });
      }

      snowflakes.length = 0;
      for (let i = 0; i < 200; i++) {
        snowflakes.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 1 + Math.random() * 2.5,
          vy: 0.5 + Math.random() * 1.2,
          vx: -0.3 + Math.random() * 0.6,
        });
      }
    }

    function drawSky() {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, "#0b1f4b");
      grad.addColorStop(0.4, "#0b3a7a");
      grad.addColorStop(1, "#030712");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars should appear ONLY on win
      const shouldDrawStars = !!finished;
      window.__starsRendered = shouldDrawStars;
      if (!shouldDrawStars) return;

      const now = Date.now() / 1000;
      stars.forEach(s => {
        const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(now * s.speed + s.phase));
        ctx.globalAlpha = s.baseAlpha * twinkle;
        ctx.fillStyle = "#f9fafb";
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    }

    function updateSnow() {
      snowflakes.forEach(f => {
        f.y += f.vy;
        f.x += f.vx;
        if (f.y > canvas.height + 5) {
          f.y = -5;
          f.x = Math.random() * canvas.width;
        }
        if (f.x < -10) f.x = canvas.width + 10;
        if (f.x > canvas.width + 10) f.x = -10;
      });
    }

    function drawSnow() {
      ctx.fillStyle = "#e5f2ff";
      snowflakes.forEach(f => {
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    }

    function drawDust() {
      // Sparkle dust should appear ONLY after winning
      if (!finished) return;
      for (let i = dust.length - 1; i >= 0; i--) {
        const p = dust[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.02;
        p.life -= 1;
        if (p.life <= 0) {
          dust.splice(i, 1);
          continue;
        }
        ctx.globalAlpha = Math.max(0, p.life / 80);
        ctx.fillText("‚ú®", p.x, p.y);
        ctx.globalAlpha = 1;
      }
    }

    function canMove(dx, dy, testShape = currentPackage.shape) {
      if (!currentPackage) return false;
      return testShape.every((row, r) =>
        row.every((val, c) => {
          if (!val) return true;
          const nx = currentPackage.x + c + dx;
          const ny = currentPackage.y + r + dy;
          if (nx < 0 || nx >= gridCols || ny >= gridRows) return false;
          if (ny >= 0 && grid[ny][nx]) return false;
          return true;
        })
      );
    }

    function rotateShape(shape) {
      const h = shape.length;
      const w = shape[0].length;
      const rotated = Array.from({ length: w }, () => Array(h).fill(0));
      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          rotated[c][h - 1 - r] = shape[r][c];
        }
      }
      return rotated;
    }

    function tryRotate() {
      if (!currentPackage) return;
      const rotated = rotateShape(currentPackage.shape);
      if (canMove(0, 0, rotated)) {
        currentPackage.shape = rotated;
      }
    }

    function lockPackage() {
      if (currentPackage.y < 0) {
        resetGame();
        return;
      }

      currentPackage.shape.forEach((row, r) => {
        row.forEach((val, c) => {
          if (val) grid[currentPackage.y + r][currentPackage.x + c] = 1;
        });
      });

      packagesLoaded++;

      const holesNow = countHoles();
      const holesDelta = holesNow - prevHoles;
      const doingBad = (holesDelta >= 2) || (holesNow > 6);
      prevHoles = holesNow;

      if (doingBad) {
        showSanta(santaBadComment, true);
      } else {
        if (Math.random() < 0.28) showSanta(randomGoodComment(), false);
      }

      if (packagesLoaded === halfwayPackages) {
        reindeerShake = 10;
        setTimeout(() => (reindeerShake = 0), 300);
      }

      if (packagesLoaded >= targetPackages) {
        finishGame(true);
        return;
      }

      currentPackage = newPackage();
    }

    function finishGame(animate = true) {
      finished = true;
      statusEl.textContent = "Merry Christmas!";
      showSanta("Very good, very good!", false);

      if (animate) {
        // Animate sleigh taking off
        const flyDuration = 1200;
        const start = performance.now();

        function fly(now) {
          const tt = Math.min(1, (now - start) / flyDuration);
          window.sledFlyOffsetX = tt * (canvas.width + 2200);
          window.sledFlyOffsetY = -tt * 220;
          if (tt < 1) requestAnimationFrame(fly);
        }

        window.sledFlyOffsetX = 0;
        window.sledFlyOffsetY = 0;
        requestAnimationFrame(fly);
      }

      // Sparkle trail
      for (let i = 0; i < 140; i++) {
        const angle = (-Math.PI / 2) + (Math.random() - 0.5) * 0.9; // wider spread
        const speed = 10 + Math.random() * 8; // much faster
        dust.push({
          x: sledX + gridCols * cell + 40,
          y: sledY - 20 + Math.random() * 140,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 35 + Math.floor(Math.random() * 25), // fade out faster
        });
      }
    }

    function resetGame() {
      grid = Array.from({ length: gridRows }, () => Array(gridCols).fill(0));
      packagesLoaded = 0;
      currentPackage = newPackage();
      reindeerShake = 0;
      finished = false;
      gameOver = false;
      dust.length = 0;
      prevHoles = 0;
      window.sledFlyOffsetX = 0;
      window.sledFlyOffsetY = 0;
      statusEl.textContent = `Load the packages (${targetPackages} packages)`;
      santaIntroDone = false;
    }

    // Input
    document.addEventListener("keydown", (e) => {
      playMusic();

      if (!santaIntroDone) {
        santaIntroDone = true;
        showSanta("Hou hou, let's go!", false);
      }

      if (e.key === "r" || e.key === "R") {
        resetGame();
        return;
      }

      if (!currentPackage || finished || gameOver) return;

      if (e.key === "ArrowLeft" && canMove(-1, 0)) currentPackage.x--;
      if (e.key === "ArrowRight" && canMove(1, 0)) currentPackage.x++;
      if (e.key === "ArrowDown" && canMove(0, 1)) currentPackage.y++;
      if (e.key === "ArrowUp") tryRotate();
    });

    // Falling speed
    let fallCounter = 0;
    const fallSpeed = 5;

    function update() {
      if (finished || gameOver) {
        updateSnow();
        return;
      }

      fallCounter++;
      if (fallCounter < fallSpeed) {
        updateSnow();
        return;
      }
      fallCounter = 0;

      if (canMove(0, 1)) {
        currentPackage.y++;
      } else {
        lockPackage();
      }

      updateSnow();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawSky();
      drawSnow();

      const remaining = Math.max(0, targetPackages - packagesLoaded);
      if (!finished && !gameOver) {
        const msg = `${remaining} packages remaining`;
        const x = sledX + (gridCols * cell) / 2;
        const y = sledY - 45;
        ctx.font = "bold 34px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = 6;
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.strokeText(msg, x, y);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(msg, x, y);
        ctx.textAlign = "start";
        ctx.textBaseline = "alphabetic";
      }

      drawSled();
      drawGrid();
      drawCurrentPackage();

      if (finished) {
        ctx.font = "bold 96px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        ctx.lineWidth = 10;
        ctx.strokeText("Merry Christmas!", canvas.width / 2, canvas.height / 2);
        ctx.fillText("Merry Christmas!", canvas.width / 2, canvas.height / 2);
        ctx.textAlign = "start";
      }

      drawDust();

      if (gameOver) {
        ctx.fillText("üí•", sledX + 120, sledY - 40);
      }
    }

    // --- Lightweight self-tests ---
    function runSelfTests() {
      try {
        const p = newPackage();
        console.assert(p && typeof p === "object", "newPackage() pit√§isi palauttaa objekti");
        console.assert(Array.isArray(p.shape), "Pakettimuodon pit√§isi olla taulukko");
        console.assert(typeof p.x === "number" && typeof p.y === "number", "x/y pit√§isi olla numeroita");

        const rotated = rotateShape(p.shape);
        const count = s => s.flat().reduce((a, b) => a + b, 0);
        console.assert(count(rotated) === count(p.shape), "Py√∂r√§ytys ei saa muuttaa palojen m√§√§r√§√§");

        currentPackage = newPackage();
        console.assert(typeof canMove(0, 1) === "boolean", "canMove() pit√§isi palauttaa boolean");

        initStarsAndSnow();
        console.assert(stars.length === 80, `T√§htien m√§√§r√§ odotettu 80, saatiin ${stars.length}`);
        console.assert(snowflakes.length === 200, `Lumihiutaleiden m√§√§r√§ odotettu 200, saatiin ${snowflakes.length}`);

        let threw = false;
        try { drawSled(); } catch (e) { threw = true; }
        console.assert(!threw, "drawSled() ei saisi heitt√§√§ poikkeusta");

        console.assert(!!document.getElementById("santa"), "#santa pit√§isi l√∂yty√§ DOM:sta");
        console.assert(!!document.getElementById("santaBubble"), "#santaBubble pit√§isi l√∂yty√§ DOM:sta");
        let santaThrew = false;
        try { showSanta("Test comment", false); } catch (e) { santaThrew = true; }
        console.assert(!santaThrew, "showSanta() ei saisi heitt√§√§ poikkeusta");

        console.assert(!!document.querySelector("#santa .santaBody"), ".santaBody pit√§isi l√∂yty√§ DOM:sta");

        const holes = countHoles();
        console.assert(Number.isFinite(holes) && holes >= 0, `countHoles() pit√§isi olla >= 0, saatiin ${holes}`);

        console.assert(typeof logoImg.src === "string" && logoImg.src.startsWith("data:image/png;base64,"), "logoImg.src pit√§isi olla data:image/png;base64,...");

        // Stars should NOT render before win; should render after win
        const prevFinishedStars = finished;
        finished = false;
        drawSky();
        console.assert(window.__starsRendered === false, "Stars should not render before win");
        finished = true;
        drawSky();
        console.assert(window.__starsRendered === true, "Stars should render on win");
        finished = prevFinishedStars;

        // finishGame should not throw and should set finished=true (no animation)
        let finishThrew = false;
        try {
          const prevFinished = finished;
          finishGame(false);
          console.assert(finished === true, "finishGame() pit√§isi asettaa finished=true");
          finished = prevFinished;
          window.sledFlyOffsetX = 0;
          window.sledFlyOffsetY = 0;
        } catch (e) {
          finishThrew = true;
        }
        console.assert(!finishThrew, "finishGame() ei saisi heitt√§√§ poikkeusta");

        currentPackage = p;
      } catch (err) {
        console.error("SelfTests ep√§onnistui:", err);
      }
    }

    (function testSantaHeadSize(){
      const el = document.querySelector('#santa .santaEmoji');
      if (!el) { console.assert(false, 'santaEmoji puuttuu'); return; }
      const fs = parseFloat(getComputedStyle(el).fontSize);
      console.assert(fs >= 100, `Pukin p√§√§n fonttikoon pit√§isi olla >= 100px, saatiin ${fs}`);
    })();

    // NEW: ensure finishGame doesn't start flight when animate=false
    (function testFinishGameNoFlightWhenAnimateFalse(){
      const prevX = window.sledFlyOffsetX;
      const prevY = window.sledFlyOffsetY;
      window.sledFlyOffsetX = 123;
      window.sledFlyOffsetY = 456;
      finishGame(false);
      console.assert(window.sledFlyOffsetX === 123 && window.sledFlyOffsetY === 456, "finishGame(false) should not change fly offsets");
      // restore
      window.sledFlyOffsetX = prevX;
      window.sledFlyOffsetY = prevY;
      finished = false;
    })();

    // NEW: when animate=true, final X offset should be far beyond canvas width
    (function testFinishGameAnimateDistance(){
      // simulate the intended end-state of the animation (tt=1)
      const target = (canvas.width + 2200);
      console.assert(target > canvas.width + 1000, `fly distance should be big enough, got ${target}`);
    })();

    runSelfTests();

    setInterval(() => {
      update();
      draw();
    }, 200);
  </script>
</body>
</html>
